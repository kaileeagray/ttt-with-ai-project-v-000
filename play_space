
Quote from Wikipedia (Tic Tac Toe#Strategy)

A player can play a perfect game of Tic-tac-toe (to win or, at least, draw) if they choose the first available move from the following list, each turn, as used in Newell and Simon's 1972 tic-tac-toe program.[6]

Win: If you have two in a row, play the third to get three in a row.
Block: If the opponent has two in a row, play the third to block them.
Fork: Create an opportunity where you can win in two ways.
Block Opponent's Fork:

Option 1: Create two in a row to force the opponent into defending,
as long as it doesn't result in them creating a fork or winning.
For example, if "X" has a corner, "O" has the center, and "X" has the opposite
corner as well, "O" must not play a corner in order to win. (Playing a corner
in this scenario creates a fork for "X" to win.)

Option 2: If there is a configuration where the opponent can fork, block that fork.
Center: Play the center.
Opposite Corner: If the opponent is in the corner, play the opposite corner.
Empty Corner: Play an empty corner.
Empty Side: Play an empty side.



def won?
  won = false
  WIN_COMBINATIONS.each_with_index do |win_combo, index|
    if
      self.save_winner = board[win_combo[0]]
    end
  end
  won
end

(board[win_combo[0]] == board[win_combo[1]] || board[win_combo[0]] == board[win_combo[2]] || board[win_combo[2]] == board[win_combo[2]]) && (board[win_combo[0]] != " " || board[win_combo[1]] != " " ||board[win_combo[2]] != " ")

(board[win_combo[0]] == " ") ^ (board[win_combo[1]] == " ") ^ (board[win_combo[2]] == " ")

uneven_true = (board[win_combo[0]] == " ") ^ (board[win_combo[1]] == " ") ^ (board[win_combo[2]] == " ")
max_one_true = (!((board[win_combo[0]] == " ") && (board[win_combo[1]] == " "))) && (!((board[win_combo[0]] == " ") && (board[win_combo[2]] == " "))) && (!((board[win_combo[2]] == " ") && (board[win_combo[1]] == " ")))
exactly_one_true = uneven_true && max_one_true

rom itertools import product

print("x|y|z|only_one_is_true")
print("======================")
for x, y, z in product([True, False], repeat=3):
    uneven_number_is_true = x ^ y ^ z
    max_one_is_true = (not (x and y)) and (not (x and z)) and (not (y and z))
    only_one_is_true = uneven_number_is_true and max_one_is_true
    print(int(x), int(y), int(z), only_one_is_true)
And here's the output.

x|y|z|only_one_is_true
======================
1 1 1 False
1 1 0 False
1 0 1 False
1 0 0 True
0 1 1 False
0 1 0 True
0 0 1 True
0 0 0 False

board[combo[0]] == board[combo[1]] || board[combo[0]] == board[combo[2]] || board[combo[2]] == board[combo[2]]
